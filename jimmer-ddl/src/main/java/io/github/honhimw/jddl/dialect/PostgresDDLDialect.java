package io.github.honhimw.jddl.dialect;

import io.github.honhimw.jddl.DatabaseVersion;
import org.babyfish.jimmer.sql.EnumType;
import org.babyfish.jimmer.sql.dialect.PostgresDialect;
import org.jspecify.annotations.Nullable;

import java.util.UUID;

import static java.sql.Types.*;

/**
 * @author honhimW
 */

public class PostgresDDLDialect extends DefaultDDLDialect {

    public PostgresDDLDialect() {
        this(null);
    }

    public PostgresDDLDialect(final DatabaseVersion version) {
        super(new PostgresDialect(), version);
    }

    @Override
    public String getIdentityColumnString(int type) {
        return "generated by default as identity";
    }

    @Override
    public String columnType(int jdbcType, Long length, Integer precision, Integer scale) {
        length = getLength(jdbcType, length);
        precision = getPrecision(jdbcType, precision);
        scale = getScale(jdbcType, scale);
        switch (jdbcType) {
            case TINYINT:
                // no tinyint, not even in Postgres 11
                return "smallint";
            // there are no nchar/nvarchar types in Postgres
            case NCHAR:
                return columnType(CHAR, length, precision, scale);
            case NVARCHAR:
                return columnType(VARCHAR, length, precision, scale);

            // since there's no real difference between TEXT and VARCHAR,
            // except for the length limit, we can just use 'text' for the
            // "long" string types
            case LONGVARCHAR:
            case LONGNVARCHAR:
                return "text";

            case BLOB:
            case CLOB:
            case NCLOB:
                // use oid as the blob/clob type on Postgres because
                // the JDBC driver doesn't allow using bytea/text via
                // LOB APIs
                return "oid";
            case FLOAT:
                return "float4";
            case SQLXML:
                return "xml";
            // use bytea as the "long" binary type (that there is no
            // real VARBINARY type in Postgres, so we always use this)
            case BINARY:
            case VARBINARY:
            case LONGVARBINARY:
                return "bytea";
            case TIMESTAMP:
                return columnType(TIME_WITH_TIMEZONE, length, precision, scale);
            default:
                return super.columnType(jdbcType, length, precision, scale);
        }
    }

    @Override
    public String resolveSqlType(Class<?> type, EnumType.@Nullable Strategy strategy) {
        if (type == UUID.class) {
            return "uuid";
        }
        return super.resolveSqlType(type, strategy);
    }

    @Override
    public String getCascadeConstraintsString() {
        return "cascade";
    }

    @Override
    public boolean supportsIfExistsAfterAlterTable() {
        return true;
    }

}
